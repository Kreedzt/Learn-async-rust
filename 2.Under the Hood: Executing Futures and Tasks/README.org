* 了解 future 调度
** Future trait
   ~Future~ trait 简单实现:
   #+begin_src rust
     trait Simple Future {
         type Output;
         // wake 为执行成功后回调
         fn poll(&mut self, wake: fn()) -> Poll<Self::Output>;
     }

     enum Poll<T> {
         Ready(T), // 完成
         Pending // 执行中
     }
   #+end_src

   #+begin_src rust
     pub struct SocketRead<'a> {
         socket: &'a Socket,
     }

     impl SimpleFuture for SocketRead<'_> {
         type Output = Vec<u8>;

         fn poll(&mut self, wake: fn()) -> Poll<Self::Output> {
             if self.socket.has_data_to_read() {
                 Poll::Ready(self.socket.read_buf())
             } else {
                 self.socket.set_readable_callback(wake);
                 Poll::Pending
             }
         }
     }
   #+end_src

   ~join~ 实现: (依次执行)
   #+begin_src rust
     pub struct AndThenFut<FutureA, FutureB> {
         first: Option<FutureA>,
         second: FutureB
     }

     impl<FutureA, FutureB> SimpleFuture for AndThenFut<FutureA, FutureB>
     where
         FutureA: SimpleFuture<Output = ()>,
         FutureB: SimpleFuture<Output = ()>,
     {
         type Output = ();

         fn poll(&mut self, wake: fn()) -> Poll<Self::Output> {
             if let Some(first) = &mut self.first {
                 match first.poll(wake) {
                     Poll::Ready(()) => self.first.take(),
                     Poll::Pending => return Poll::Pending,
                 }
             }

             self.second.poll(wake)
         }
     }
   #+end_src

   ~Future~ 真实实现:
   #+begin_src rust
     trait Future {
         type Output;

         fn poll(
             self: Pin<&mut Self>,
             cx: &mut Context<'_>,
         ) -> Poll<Self::Output>;
     }
   #+end_src
